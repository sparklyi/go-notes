##  分布式笔记

### 分布式理论

#### CAP理论

**Consistency (一致性)**

更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致

**Availability (可用性)**

服务一直可用，而且是正常响应时间

**Partition Tolerance (分区容错性)**

分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务

**CAP只能满足两个 不可能全部满足**

**CA**

C（强一致性）和A（可用性）可以保证，违背分布式系统设计的初衷

**CP**

每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统

**AP**

要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性

----

#### BASE理论



**Basically Available（基本可用）**

基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性

**Soft state（软状态）**

允许系统在不同节点的数据副本之间进行数据同步的过程存在延时

**Eventually consistent（最终一致性）**

最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态



**即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性**

----

### 本地事务

本地事务四大属性：ACID

- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

#### 原子性[atomicity]

原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态

#### 一致性[consistency]

一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见 

#### 隔离性[isolation]

多个事务的时候, 相互不能干扰

**四种隔离级别（串行化、可重复读、读已提交、读未提交）**

读未提交，指一个事务还没提交时，它做的变更就能被其他事务看到

读提交，指一个事务提交之后，它做的变更才能被其他事务看到；

可重复读，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的

串行化，加读写锁执行，不会存在脏读、不可重复读、幻读的情况

**脏读** 指的是一个事务读取了另一个事务尚未提交的数据

**不可重复读** 指的是在同一事务中，前后两次读取同一数据，结果却不一致

**幻读** 指的是事务A在某个范围内查询了一些记录，但当它再次查询相同范围时，却发现有新的记录插入了，导致查询结果发生变化。

#### 持久性[durability]

事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

----

### 分布式事务

#### 2PC

2PC 协议将事务的提交过程分为两个阶段：**准备阶段** 和 **提交阶段**。在这两个阶段中，有一个**协调者（Coordinator）**，负责协调各个参与者的操作，而**参与者（Participants）**是指实际执行事务的节点。

##### 阶段1：准备阶段
协调者 --> 参与者1：准备提交？
协调者 --> 参与者2：准备提交？
参与者1 --> 协调者：Yes / No
参与者2 --> 协调者：Yes / No

##### 阶段2：提交/回滚阶段
如果所有参与者都返回 Yes：
协调者 --> 参与者1：提交
协调者 --> 参与者2：提交
如果有任何参与者返回 No：
协调者 --> 参与者1：回滚
协调者 --> 参与者2：回滚

##### 2PC的优点

**简单明了**：2PC 的流程清晰，逻辑简单，能够确保分布式事务的原子性。

**适用于多数场景**：许多分布式系统场景中，2PC 能够满足一致性的需求，确保分布式事务的可靠执行。

##### 2PC 的缺点

1. **性能问题**：
   - 2PC 需要多个网络通信来完成整个事务的提交，这增加了事务的延迟。每个参与者在第一阶段必须等待其他参与者的响应，这导致了等待时间的增加。
2. **阻塞问题**：
   - 如果协调者在第一阶段或第二阶段发生故障，参与者将处于“阻塞”状态（等待协调者的指令），从而无法继续执行其他事务。这种情况下，系统的可用性会受到影响。
3. **脑裂问题**：
   - 如果在提交阶段协调者和参与者网络中断，协调者可能无法知道参与者是否提交或回滚，从而可能出现“脑裂”现象，导致数据不一致。
4. **单点故障**：
   - 2PC 的协调者是单点，一旦协调者发生故障，整个事务就可能无法继续进行，参与者必须等待协调者恢复或者进行手动处理。

----

#### 3PC

**在2PC的基础增加了预提交阶段**

##### 阶段1：可以提交阶段
协调者 --> 参与者1：可以提交吗？
协调者 --> 参与者2：可以提交吗？
参与者1 --> 协调者：Yes / No
参与者2 --> 协调者：Yes / No

##### 阶段2：预提交阶段
协调者 --> 参与者1：预提交
协调者 --> 参与者2：预提交
参与者1 --> 协调者：ACK
参与者2 --> 协调者：ACK
##### 阶段3：提交/回滚阶段
如果所有参与者返回 ACK：
协调者 --> 参与者1：提交
协调者 --> 参与者2：提交
如果有任何参与者未返回 ACK：
协调者 --> 参与者1：回滚
协调者 --> 参与者2：回滚

##### 3PC 的优点

1. **更好的容错性**：
   - 3PC 在 2PC 的基础上引入了预提交阶段，使得系统在协调者出现故障时仍然有恢复的可能，参与者可以根据超时机制回滚事务，避免长时间阻塞。
2. **减少了阻塞风险**：
   - 由于引入了明确的状态日志和超时机制，参与者在协调者失联时可以做出合理决策，避免系统陷入无法继续的状态。

----

#### TCC

try->confirm->cancel三阶段

**全局事务开始**：**事务管理器**发起事务，将事务分为多个子事务

##### **Try 阶段**：资源预留

- 尝试执行业务操作，检查并预留每个分支的资源，但不真正执行业务。可以理解为预占用资源，这一步确保后续的事务可以执行。
- 该阶段会校验业务系统的所有操作条件是否满足，同时锁定或预占资源

##### **Confirm 阶段**：确认提交

- 该阶段真正执行操作，在 `Try` 成功的情况下，`Confirm` 操作会提交事务。
- 一旦 `Confirm` 被执行，就不允许失败。此阶段应确保尽可能的成功率（通常设计为幂等操作）。

##### **Cancel 阶段**：事务回滚

- 如果 `Try` 操作失败或者某个服务的 `Confirm` 阶段失败，则会调用 `Cancel` 进行回滚。
- 这个阶段撤销 `Try` 阶段中的预留资源或回滚已经执行的操作。比如在资金冻结的例子中，这里会解冻资金。

##### TCC 的优势

1. **高并发**：通过将资源的预留和确认分开，TCC 能够避免长时间持有锁，提升了系统的并发处理能力。
2. **灵活性**：TCC 允许各个子事务可以自行定义其操作的逻辑。
3. **精确控制**：TCC 模式能精确控制事务的各个步骤，确保了在分布式环境中不同系统之间的数据一致性。

##### TCC缺点

1. 侵入性强，每个事务都必须实现try，confirm，cancel等3个方法，开发成本高
2. 为了达到事务的一致性要求，try，confirm、cancel接口必须实现等幂性操作。 （定时器+重试）
3. 由于事务管理器要记录事务日志，必定会损耗一定的性能，并使得整个TCC事务时间拉长，建议采用redis的方式来记录事务日志。
4. tcc需要通过锁来确保数据的一致性，会加锁导致性能不高

##### tips

- 默认 Confirm 阶段是不会出错的，也就是说只要 Try 成功，Confirm 一定成功（TCC设计之初的定义）

- Confirm 与 Cancel 如果失败，由TCC框架进行重试补偿

- 存在极低概率在CC环节彻底失败，则需要定时任务或人工介入

----



#### 本地消息表实现最终一致性

通过本地事务保证数据业务操作和消息的一致性，在**本地事务**中完成业务处理和记录事务消息，然后通过**定时任务**将本地事务消息发送至MQ，待确认消息发送给消费方成功再将消息删除

使用MQ的ack（即消息确认）机制，消费者监听MQ，如果消费者接收到消息并且业务处理完成后向MQ发送ack（即消息确认），此时说明消费者正常消费消息完成，MQ将不再向消费者推送消息，否则消费者会不断重试向消费者来发送消息。

**可能存在重复投递消息 所以需要实现幂等性**

优点：

- 从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。
- 方案轻量，容易实现。

缺点

- 与具体的业务场景绑定，耦合性强，不可公用
- 消息数据与业务数据同库，占用业务系统资源
- 业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限

----



#### **基于可靠消息的最终一致性** 

**保证消息的可靠投递**和**通过补偿机制达成最终一致性**，而不是要求每一步操作都保持强一致性

**基于可靠消息的最终一致性通常直接依赖外部消息队列系统的可靠性和持久化能力**

通过消息队列来协调各个子系统之间的数据变更。通过异步通信，消息可以在多个子系统之间传递，即使系统出现短暂的故障，消息也不会丢失，而是最终能够确保数据一致。

##### 优点

- 消息数据独立存储 ，降低业务系统与消息系统之间的耦合
- 吞吐量大于使用本地消息表方案

##### 缺点

- 一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 。
- 业务处理服务需要实现消息状态回查接口

----

#### 最大努力通知

最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在**事务主动方增加了消息校对的接口**，如果事务被动方没有接收到主动方发送的消息，此时可以调用事务主动方提供的消息校对的接口主动获取

最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。

----